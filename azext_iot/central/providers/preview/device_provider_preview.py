# coding=utf-8
# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------

from knack.util import CLIError
from knack.log import get_logger
from typing import List
from azext_iot.constants import CENTRAL_ENDPOINT
from azext_iot.central import services as central_services
from azext_iot.central.models.enum import DeviceStatus
from azext_iot.dps.services import global_service as dps_global_service
from azext_iot.sdk.central.iot_central_api_preview import IotCentralApiPreview
from azext_iot.sdk.central.iot_central_api_preview.models import Device
from azext_iot.central.services import _utility
from azext_iot.central.utils import parse_device_status
from azext_iot.central.utils import dps_populate_essential_info
from azext_iot.central.models.enum import DeviceStatus

logger = get_logger(__name__)


class CentralDeviceProviderPreview:
    def __init__(self, cmd, app_id: str, token=None):
        """
        Provider for device APIs

        Args:
            cmd: command passed into az
            app_id: name of app (used for forming request URL)
            token: (OPTIONAL) authorization token to fetch device details from IoTC.
                MUST INCLUDE type (e.g. 'SharedAccessToken ...', 'Bearer ...')
                Useful in scenarios where user doesn't own the app
                therefore AAD token won't work, but a SAS token generated by owner will
        """
        self._cmd = cmd
        self._app_id = app_id
        self._token = token
        self._devices = {}
        self._device_templates = {}
        self._device_credentials = {}
        self._device_registration_info = {}


    def get_device(self, device_id, central_dns_suffix=CENTRAL_ENDPOINT) -> Device:
        if not device_id:
            raise CLIError("Device id must be specified.")
        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)
        return apiClient.devices.get(device_id)

    def delete_device(self, device_id, central_dns_suffix=CENTRAL_ENDPOINT) -> Device:
        if not device_id:
            raise CLIError("Device id must be specified.")
        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)
        return apiClient.devices.remove(device_id)

    def create_device(
        self,
        device_id,
        device_name=None,
        instance_of=None,
        simulated=False,
        central_dns_suffix=CENTRAL_ENDPOINT,
    ) -> Device:
        if not device_id:
            raise CLIError("Device id must be specified.")

        if device_id in self._devices:
            raise CLIError("Device already exists.")

        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)

        device = Device()
        device.display_name = device_name
        device.instance_of = instance_of
        device.simulated = simulated
        result = apiClient.devices.set(device_id, device)
        if not result:
            raise CLIError("No device found with id: '{}'.".format(device_id))
        return result

    def get_device_credentials(
        self, device_id, central_dns_suffix=CENTRAL_ENDPOINT,
    ) -> dict:
        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)

        credentials = apiClient.devices.get_credentials(device_id)

        if not credentials:
            raise CLIError(
                "Could not find device credentials for device '{}'.".format(device_id)
            )

        return credentials

    def get_device_registration_info(
        self,
        device_id,
        central_dns_suffix=CENTRAL_ENDPOINT,
    ) -> dict:
        dps_state = {}

        device = self.get_device(device_id, central_dns_suffix)
        status = parse_device_status(device)
        if status == DeviceStatus.provisioned:
            credentials = self.get_device_credentials(
                device_id=device_id, central_dns_suffix=central_dns_suffix
            )
            id_scope = credentials["idScope"]
            key = credentials["symmetricKey"]["primaryKey"]
            dps_state = dps_global_service.get_registration_state(
                id_scope=id_scope, key=key, device_id=device_id
            )
        dps_state = dps_populate_essential_info(dps_state, status)

        registration_info = {
            "device_status": status.value,
            "display_name": device.display_name,
            "id": device.id,
            "simulated": device.simulated,
            "instance_of": device.instance_of,
        }

        info = {
            "@device_id": device_id,
            "dps_state": dps_state,
            "device_registration_info": registration_info,
        }

        return info

    def run_component_command(
        self,
        device_id: str,
        interface_id: str,
        command_name: str,
        payload: dict,
        central_dns_suffix=CENTRAL_ENDPOINT,
    ):
        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)
        return apiClient.devices.execute_component_command(device_id, interface_id, command_name, payload)

    def get_component_command_history(
        self,
        device_id: str,
        interface_id: str,
        command_name: str,
        central_dns_suffix=CENTRAL_ENDPOINT,
    ):
        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)
        return apiClient.devices.get_component_command_history(device_id, interface_id, command_name)


    def get_device_registration_summary(self, central_dns_suffix=CENTRAL_ENDPOINT):
        token = _utility.get_token_credential(self._cmd)
        apiClient = IotCentralApiPreview(token, self._app_id, central_dns_suffix)
        
        logger.warning(
        "This command may take a long time to complete if your app contains a lot of devices"
        )
        
        devices = apiClient.devices.list()
        registration_summary = {status.value: 0 for status in DeviceStatus}
        for device in devices:
            status = parse_device_status(device)
            registration_summary[status.value] += 1
        return registration_summary
