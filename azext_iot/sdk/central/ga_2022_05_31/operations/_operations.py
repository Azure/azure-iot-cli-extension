# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
from urllib.parse import parse_qs, urljoin, urlparse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models as _models
from .._serialization import Serializer
from .._vendor import _format_url_section
from ..models._models import (
    ApiTokenCollection,
    DeviceCollection,
    DeviceCommandCollection,
    DeviceGroupCollection,
    DeviceTemplateCollection,
    OrganizationCollection,
    RoleCollection,
    UserCollection,
)

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_api_tokens_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/apiTokens"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_api_tokens_get_request(token_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/apiTokens/{tokenId}"
    path_format_arguments = {
        "tokenId": _SERIALIZER.url("token_id", token_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_api_tokens_create_request(token_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/apiTokens/{tokenId}"
    path_format_arguments = {
        "tokenId": _SERIALIZER.url("token_id", token_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_api_tokens_remove_request(token_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/apiTokens/{tokenId}"
    path_format_arguments = {
        "tokenId": _SERIALIZER.url("token_id", token_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_groups_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceGroups"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_groups_get_request(device_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceGroups/{deviceGroupId}"
    path_format_arguments = {
        "deviceGroupId": _SERIALIZER.url(
            "device_group_id", device_group_id, "str", max_length=255, pattern=r"^[a-zA-Z0-9_-]*$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_groups_create_request(device_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceGroups/{deviceGroupId}"
    path_format_arguments = {
        "deviceGroupId": _SERIALIZER.url(
            "device_group_id", device_group_id, "str", max_length=255, pattern=r"^[a-zA-Z0-9_-]*$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_groups_update_request(device_group_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceGroups/{deviceGroupId}"
    path_format_arguments = {
        "deviceGroupId": _SERIALIZER.url(
            "device_group_id", device_group_id, "str", max_length=255, pattern=r"^[a-zA-Z0-9_-]*$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_device_groups_remove_request(device_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceGroups/{deviceGroupId}"
    path_format_arguments = {
        "deviceGroupId": _SERIALIZER.url(
            "device_group_id", device_group_id, "str", max_length=255, pattern=r"^[a-zA-Z0-9_-]*$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_templates_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceTemplates"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_templates_get_request(device_template_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceTemplates/{deviceTemplateId}"
    path_format_arguments = {
        "deviceTemplateId": _SERIALIZER.url("device_template_id", device_template_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_templates_create_request(device_template_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceTemplates/{deviceTemplateId}"
    path_format_arguments = {
        "deviceTemplateId": _SERIALIZER.url("device_template_id", device_template_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_templates_update_request(device_template_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceTemplates/{deviceTemplateId}"
    path_format_arguments = {
        "deviceTemplateId": _SERIALIZER.url("device_template_id", device_template_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_device_templates_remove_request(device_template_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/deviceTemplates/{deviceTemplateId}"
    path_format_arguments = {
        "deviceTemplateId": _SERIALIZER.url("device_template_id", device_template_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_create_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_update_request(device_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_devices_remove_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_attestation_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/attestation"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_create_attestation_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/attestation"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_update_attestation_request(device_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/attestation"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_devices_remove_attestation_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/attestation"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_command_history_request(device_id: str, command_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_run_command_request(device_id: str, command_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_list_components_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_component_command_history_request(
    device_id: str, component_name: str, command_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components/{componentName}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_run_component_command_request(
    device_id: str, component_name: str, command_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components/{componentName}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_component_properties_request(device_id: str, component_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components/{componentName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_replace_component_properties_request(
    device_id: str, component_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components/{componentName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_update_component_properties_request(
    device_id: str, component_name: str, *, json: JSON, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components/{componentName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_devices_get_component_telemetry_value_request(
    device_id: str, component_name: str, telemetry_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/components/{componentName}/telemetry/{telemetryName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
        "telemetryName": _SERIALIZER.url("telemetry_name", telemetry_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_credentials_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/credentials"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_list_modules_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_module_command_history_request(
    device_id: str, module_name: str, command_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_run_module_command_request(
    device_id: str, module_name: str, command_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_list_module_components_request(device_id: str, module_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_module_component_command_history_request(
    device_id: str, module_name: str, component_name: str, command_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components/{componentName}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_run_module_component_command_request(
    device_id: str, module_name: str, component_name: str, command_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components/{componentName}/commands/{commandName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
        "commandName": _SERIALIZER.url("command_name", command_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_module_component_properties_request(
    device_id: str, module_name: str, component_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components/{componentName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_replace_module_component_properties_request(
    device_id: str, module_name: str, component_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components/{componentName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_update_module_component_properties_request(
    device_id: str, module_name: str, component_name: str, *, json: JSON, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components/{componentName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_devices_get_module_component_telemetry_value_request(
    device_id: str, module_name: str, component_name: str, telemetry_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/components/{componentName}/telemetry/{telemetryName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "componentName": _SERIALIZER.url("component_name", component_name, "str"),
        "telemetryName": _SERIALIZER.url("telemetry_name", telemetry_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_module_properties_request(device_id: str, module_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_replace_module_properties_request(device_id: str, module_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_update_module_properties_request(
    device_id: str, module_name: str, *, json: JSON, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_devices_get_module_telemetry_value_request(
    device_id: str, module_name: str, telemetry_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/modules/{moduleName}/telemetry/{telemetryName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "moduleName": _SERIALIZER.url("module_name", module_name, "str"),
        "telemetryName": _SERIALIZER.url("telemetry_name", telemetry_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_properties_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_replace_properties_request(device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_update_properties_request(device_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/properties"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_devices_get_telemetry_value_request(device_id: str, telemetry_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/devices/{deviceId}/telemetry/{telemetryName}"
    path_format_arguments = {
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
        "telemetryName": _SERIALIZER.url("telemetry_name", telemetry_name, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_file_uploads_get_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fileUploads"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_file_uploads_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fileUploads"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_file_uploads_update_request(*, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fileUploads"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_file_uploads_remove_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fileUploads"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_organizations_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/organizations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_organizations_get_request(organization_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/organizations/{organizationId}"
    path_format_arguments = {
        "organizationId": _SERIALIZER.url(
            "organization_id", organization_id, "str", max_length=48, pattern=r"^(?!-)[a-z0-9-]{1,48}[a-z0-9]$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_organizations_create_request(organization_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/organizations/{organizationId}"
    path_format_arguments = {
        "organizationId": _SERIALIZER.url(
            "organization_id", organization_id, "str", max_length=48, pattern=r"^(?!-)[a-z0-9-]{1,48}[a-z0-9]$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_organizations_update_request(organization_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/organizations/{organizationId}"
    path_format_arguments = {
        "organizationId": _SERIALIZER.url(
            "organization_id", organization_id, "str", max_length=48, pattern=r"^(?!-)[a-z0-9-]{1,48}[a-z0-9]$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_organizations_remove_request(organization_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/organizations/{organizationId}"
    path_format_arguments = {
        "organizationId": _SERIALIZER.url(
            "organization_id", organization_id, "str", max_length=48, pattern=r"^(?!-)[a-z0-9-]{1,48}[a-z0-9]$"
        ),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_roles_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/roles"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_roles_get_request(role_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/roles/{roleId}"
    path_format_arguments = {
        "roleId": _SERIALIZER.url("role_id", role_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_users_list_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/users"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_users_get_request(user_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/users/{userId}"
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, "str", max_length=48, pattern=r"^[a-zA-Z0-9-_]*$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_users_create_request(user_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/users/{userId}"
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, "str", max_length=48, pattern=r"^[a-zA-Z0-9-_]*$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_users_update_request(user_id: str, *, json: JSON, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/users/{userId}"
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, "str", max_length=48, pattern=r"^[a-zA-Z0-9-_]*$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, json=json, **kwargs)


def build_users_remove_request(user_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-05-31"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/users/{userId}"
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, "str", max_length=48, pattern=r"^[a-zA-Z0-9-_]*$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


class ApiTokensOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`api_tokens` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.ApiToken"]:
        """Get the list of API tokens in an application. The token value will never be returned for
        security reasons.

        Get the list of API tokens in an application. The token value will never be returned for
        security reasons.

        :return: An iterator like instance of ApiToken
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.ApiToken]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ApiTokenCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_api_tokens_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("ApiTokenCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, token_id: str, **kwargs: Any) -> _models.ApiToken:
        """Get an API token by ID.

        Get an API token by ID.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ApiToken]

        request = build_api_tokens_get_request(
            token_id=token_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ApiToken", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self, token_id: str, body: _models.ApiToken, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ApiToken:
        """Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :param body: API token body. Required.
        :type body: ~azureiotcentral.models.ApiToken
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, token_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ApiToken:
        """Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :param body: API token body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(self, token_id: str, body: Union[_models.ApiToken, IO], **kwargs: Any) -> _models.ApiToken:
        """Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :param body: API token body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.ApiToken or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ApiToken]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ApiToken")

        request = build_api_tokens_create_request(
            token_id=token_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ApiToken", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, token_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an API token.

        Delete an API token.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_api_tokens_remove_request(
            token_id=token_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DeviceGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`device_groups` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.DeviceGroup"]:
        """Get the list of device groups in an application.

        Get the list of device groups in an application.

        :return: An iterator like instance of DeviceGroup
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.DeviceGroup]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceGroupCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_device_groups_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceGroupCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, device_group_id: str, **kwargs: Any) -> _models.DeviceGroup:
        """Get the device group by ID.

        Get the device group by ID.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceGroup]

        request = build_device_groups_get_request(
            device_group_id=device_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self, device_group_id: str, body: _models.DeviceGroup, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceGroup:
        """Create or update a device group.

        Create or update a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group body. Required.
        :type body: ~azureiotcentral.models.DeviceGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, device_group_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceGroup:
        """Create or update a device group.

        Create or update a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(self, device_group_id: str, body: Union[_models.DeviceGroup, IO], **kwargs: Any) -> _models.DeviceGroup:
        """Create or update a device group.

        Create or update a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceGroup or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceGroup]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceGroup")

        request = build_device_groups_create_request(
            device_group_id=device_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update(self, device_group_id: str, body: JSON, **kwargs: Any) -> _models.DeviceGroup:
        """Update a device group via patch.

        Update an existing device group by ID.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group patch body. Required.
        :type body: JSON
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceGroup]

        _json = self._serialize.body(body, "object")

        request = build_device_groups_update_request(
            device_group_id=device_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, device_group_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a device group.

        Delete a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_device_groups_remove_request(
            device_group_id=device_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DeviceTemplatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`device_templates` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.DeviceTemplate"]:
        """Get the list of device templates in an application.

        Get the list of device templates in an application.

        :return: An iterator like instance of DeviceTemplate
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.DeviceTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceTemplateCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_device_templates_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceTemplateCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, device_template_id: str, **kwargs: Any) -> _models.DeviceTemplate:
        """Get a device template by ID.

        Get a device template by ID.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTemplate]

        request = build_device_templates_get_request(
            device_template_id=device_template_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTemplate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self,
        device_template_id: str,
        body: _models.DeviceTemplate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceTemplate:
        """Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template body. Required.
        :type body: ~azureiotcentral.models.DeviceTemplate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, device_template_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceTemplate:
        """Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, device_template_id: str, body: Union[_models.DeviceTemplate, IO], **kwargs: Any
    ) -> _models.DeviceTemplate:
        """Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceTemplate or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTemplate]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceTemplate")

        request = build_device_templates_create_request(
            device_template_id=device_template_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTemplate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update(self, device_template_id: str, body: JSON, **kwargs: Any) -> _models.DeviceTemplate:
        """Update the cloud properties and overrides of an existing device template via patch.

        Update the cloud properties and overrides of an existing device template via patch.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template patch body. Required.
        :type body: JSON
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTemplate]

        _json = self._serialize.body(body, "object")

        request = build_device_templates_update_request(
            device_template_id=device_template_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTemplate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, device_template_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a device template.

        Delete an existing device template by device ID.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_device_templates_remove_request(
            device_template_id=device_template_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DevicesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`devices` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.Device"]:
        """Get the list of devices in an application.

        Get the list of devices in an application.

        :return: An iterator like instance of Device
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.Device]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, device_id: str, **kwargs: Any) -> _models.Device:
        """Get a device by ID.

        Get details about an existing device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Device]

        request = build_devices_get_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Device", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self, device_id: str, body: _models.Device, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Device:
        """Create or update a device.

        Create a new device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device body. Required.
        :type body: ~azureiotcentral.models.Device
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, device_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Device:
        """Create or update a device.

        Create a new device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(self, device_id: str, body: Union[_models.Device, IO], **kwargs: Any) -> _models.Device:
        """Create or update a device.

        Create a new device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Device or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Device]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Device")

        request = build_devices_create_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Device", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update(self, device_id: str, body: JSON, **kwargs: Any) -> _models.Device:
        """Update a device via patch.

        Update an existing device by ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device patch body. Required.
        :type body: JSON
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Device]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Device", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, device_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a device.

        Delete an existing device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_devices_remove_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_attestation(self, device_id: str, **kwargs: Any) -> _models.Attestation:
        """Get device attestation.

        Get device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Attestation]

        request = build_devices_get_attestation_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Attestation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create_attestation(
        self, device_id: str, body: _models.Attestation, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Attestation:
        """Create an individual device attestation.

        Create an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation body. Required.
        :type body: ~azureiotcentral.models.Attestation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_attestation(
        self, device_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Attestation:
        """Create an individual device attestation.

        Create an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_attestation(
        self, device_id: str, body: Union[_models.Attestation, IO], **kwargs: Any
    ) -> _models.Attestation:
        """Create an individual device attestation.

        Create an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Attestation or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Attestation]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Attestation")

        request = build_devices_create_attestation_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Attestation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update_attestation(self, device_id: str, body: JSON, **kwargs: Any) -> _models.Attestation:
        """Update an individual device attestation via patch.

        Update an individual device attestation via patch.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation patch body. Required.
        :type body: JSON
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Attestation]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_attestation_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Attestation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove_attestation(  # pylint: disable=inconsistent-return-statements
        self, device_id: str, **kwargs: Any
    ) -> None:
        """Remove an individual device attestation.

        Remove an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_devices_remove_attestation_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_command_history(
        self, device_id: str, command_name: str, **kwargs: Any
    ) -> Iterable["_models.DeviceCommand"]:
        """Get device command history.

        Get device command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_command_history_request(
                    device_id=device_id,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def run_command(
        self,
        device_id: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a device command.

        Run a command on a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def run_command(
        self, device_id: str, command_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a device command.

        Run a command on a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def run_command(
        self, device_id: str, command_name: str, body: Union[_models.DeviceCommand, IO], **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a device command.

        Run a command on a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_command_request(
            device_id=device_id,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_components(self, device_id: str, **kwargs: Any) -> _models.Collection:
        """List the components present in a device.

        List the components present in a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Collection
        :rtype: ~azureiotcentral.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Collection]

        request = build_devices_list_components_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_component_command_history(
        self, device_id: str, component_name: str, command_name: str, **kwargs: Any
    ) -> Iterable["_models.DeviceCommand"]:
        """Get component command history.

        Get component command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_component_command_history_request(
                    device_id=device_id,
                    component_name=component_name,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def run_component_command(
        self,
        device_id: str,
        component_name: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a component command.

        Run a command on a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def run_component_command(
        self,
        device_id: str,
        component_name: str,
        command_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a component command.

        Run a command on a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def run_component_command(
        self,
        device_id: str,
        component_name: str,
        command_name: str,
        body: Union[_models.DeviceCommand, IO],
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a component command.

        Run a command on a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_component_command_request(
            device_id=device_id,
            component_name=component_name,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_component_properties(self, device_id: str, component_name: str, **kwargs: Any) -> Dict[str, Any]:
        """Get device properties for a specific component.

        Get device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_component_properties_request(
            device_id=device_id,
            component_name=component_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def replace_component_properties(
        self,
        device_id: str,
        component_name: str,
        body: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties for a specific component.

        Replace device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties. Required.
        :type body: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace_component_properties(
        self, device_id: str, component_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties for a specific component.

        Replace device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def replace_component_properties(
        self, device_id: str, component_name: str, body: Union[Dict[str, Any], IO], **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties for a specific component.

        Replace device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_component_properties_request(
            device_id=device_id,
            component_name=component_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update_component_properties(
        self, device_id: str, component_name: str, body: JSON, **kwargs: Any
    ) -> Dict[str, Any]:
        """Update device properties for a specific component via patch.

        Update device properties for a specific component via patch.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties patch. Required.
        :type body: JSON
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_component_properties_request(
            device_id=device_id,
            component_name=component_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_component_telemetry_value(
        self, device_id: str, component_name: str, telemetry_name: str, **kwargs: Any
    ) -> _models.DeviceTelemetry:
        """Get component telemetry value.

        Get the last telemetry value from a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_component_telemetry_value_request(
            device_id=device_id,
            component_name=component_name,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_credentials(self, device_id: str, **kwargs: Any) -> _models.DeviceCredentials:
        """Get device credentials.

        Get device credentials.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: DeviceCredentials
        :rtype: ~azureiotcentral.models.DeviceCredentials
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCredentials]

        request = build_devices_get_credentials_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCredentials", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_modules(self, device_id: str, **kwargs: Any) -> _models.Collection:
        """List the modules present in a device.

        List the modules present in a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Collection
        :rtype: ~azureiotcentral.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Collection]

        request = build_devices_list_modules_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_command_history(
        self, device_id: str, module_name: str, command_name: str, **kwargs: Any
    ) -> Iterable["_models.DeviceCommand"]:
        """Get module command history.

        Get module command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_module_command_history_request(
                    device_id=device_id,
                    module_name=module_name,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def run_module_command(
        self,
        device_id: str,
        module_name: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def run_module_command(
        self,
        device_id: str,
        module_name: str,
        command_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def run_module_command(
        self, device_id: str, module_name: str, command_name: str, body: Union[_models.DeviceCommand, IO], **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_module_command_request(
            device_id=device_id,
            module_name=module_name,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def list_module_components(self, device_id: str, module_name: str, **kwargs: Any) -> _models.Collection:
        """List the components present in a module.

        List the components present in a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :return: Collection
        :rtype: ~azureiotcentral.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Collection]

        request = build_devices_list_module_components_request(
            device_id=device_id,
            module_name=module_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_component_command_history(
        self, device_id: str, module_name: str, component_name: str, command_name: str, **kwargs: Any
    ) -> Iterable["_models.DeviceCommand"]:
        """Get module component command history.

        Get module component command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_module_component_command_history_request(
                    device_id=device_id,
                    module_name=module_name,
                    component_name=component_name,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def run_module_component_command(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module component command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def run_module_component_command(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        command_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module component command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def run_module_component_command(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        command_name: str,
        body: Union[_models.DeviceCommand, IO],
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module component command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_module_component_command_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_component_properties(
        self, device_id: str, module_name: str, component_name: str, **kwargs: Any
    ) -> Dict[str, Any]:
        """Get module properties for a specific component.

        Get module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_module_component_properties_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def replace_module_component_properties(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        body: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties for a specific component.

        Replace module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties. Required.
        :type body: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace_module_component_properties(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties for a specific component.

        Replace module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def replace_module_component_properties(
        self, device_id: str, module_name: str, component_name: str, body: Union[Dict[str, Any], IO], **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties for a specific component.

        Replace module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_module_component_properties_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update_module_component_properties(
        self, device_id: str, module_name: str, component_name: str, body: JSON, **kwargs: Any
    ) -> Dict[str, Any]:
        """Update module properties for a specific component via patch.

        Update module properties for a specific component via patch.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties patch. Required.
        :type body: JSON
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_module_component_properties_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_component_telemetry_value(
        self, device_id: str, module_name: str, component_name: str, telemetry_name: str, **kwargs: Any
    ) -> _models.DeviceTelemetry:
        """Get module component telemetry value.

        Get the last telemetry value from a module component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_module_component_telemetry_value_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_properties(self, device_id: str, module_name: str, **kwargs: Any) -> Dict[str, Any]:
        """Get module properties.

        Get all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_module_properties_request(
            device_id=device_id,
            module_name=module_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def replace_module_properties(
        self,
        device_id: str,
        module_name: str,
        body: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties.

        Replace all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties. Required.
        :type body: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace_module_properties(
        self, device_id: str, module_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties.

        Replace all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def replace_module_properties(
        self, device_id: str, module_name: str, body: Union[Dict[str, Any], IO], **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties.

        Replace all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_module_properties_request(
            device_id=device_id,
            module_name=module_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update_module_properties(self, device_id: str, module_name: str, body: JSON, **kwargs: Any) -> Dict[str, Any]:
        """Update module properties via patch.

        Update property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties patch. Required.
        :type body: JSON
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_module_properties_request(
            device_id=device_id,
            module_name=module_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_telemetry_value(
        self, device_id: str, module_name: str, telemetry_name: str, **kwargs: Any
    ) -> _models.DeviceTelemetry:
        """Get module telemetry value.

        Get the last telemetry value from a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_module_telemetry_value_request(
            device_id=device_id,
            module_name=module_name,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_properties(self, device_id: str, **kwargs: Any) -> Dict[str, Any]:
        """Get device properties.

        Get all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_properties_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def replace_properties(
        self, device_id: str, body: Dict[str, Any], *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties.

        Replace all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties. Required.
        :type body: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace_properties(
        self, device_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties.

        Replace all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def replace_properties(self, device_id: str, body: Union[Dict[str, Any], IO], **kwargs: Any) -> Dict[str, Any]:
        """Replace device properties.

        Replace all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_properties_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update_properties(self, device_id: str, body: JSON, **kwargs: Any) -> Dict[str, Any]:
        """Update device properties via patch.

        Update property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties patch. Required.
        :type body: JSON
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_properties_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_telemetry_value(self, device_id: str, telemetry_name: str, **kwargs: Any) -> _models.DeviceTelemetry:
        """Get device telemetry value.

        Get the last telemetry value from a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_telemetry_value_request(
            device_id=device_id,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class FileUploadsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`file_uploads` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, **kwargs: Any) -> _models.FileUpload:
        """Get the file upload storage account configuration.

        Get the file upload storage account configuration.

        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FileUpload]

        request = build_file_uploads_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("FileUpload", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self, body: _models.FileUpload, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FileUpload:
        """Create the file upload storage account configuration.

        Create the file upload storage account configuration.

        :param body: File upload storage account configuration body. Required.
        :type body: ~azureiotcentral.models.FileUpload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(self, body: IO, *, content_type: str = "application/json", **kwargs: Any) -> _models.FileUpload:
        """Create the file upload storage account configuration.

        Create the file upload storage account configuration.

        :param body: File upload storage account configuration body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(self, body: Union[_models.FileUpload, IO], **kwargs: Any) -> _models.FileUpload:
        """Create the file upload storage account configuration.

        Create the file upload storage account configuration.

        :param body: File upload storage account configuration body. Is either a model type or a IO
         type. Required.
        :type body: ~azureiotcentral.models.FileUpload or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FileUpload]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "FileUpload")

        request = build_file_uploads_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("FileUpload", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update(self, body: JSON, **kwargs: Any) -> _models.FileUpload:
        """Update the file upload storage account configuration.

        Update the file upload storage account configuration.

        :param body: File upload storage account configuration body. Required.
        :type body: JSON
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FileUpload]

        _json = self._serialize.body(body, "object")

        request = build_file_uploads_update_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("FileUpload", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete the file upload storage configuration.

        Delete the file upload storage configuration.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_file_uploads_remove_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class OrganizationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`organizations` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.Organization"]:
        """Get the list of organizations the user has access to in an application.

        Get the list of organizations the user has access to in an application.

        :return: An iterator like instance of Organization
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.Organization]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[OrganizationCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_organizations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("OrganizationCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, organization_id: str, **kwargs: Any) -> _models.Organization:
        """Get an organization by ID.

        Get an organization by ID.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Organization]

        request = build_organizations_get_request(
            organization_id=organization_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self, organization_id: str, body: _models.Organization, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Organization:
        """Create an organization in the application.

        Create an organization in the application.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization body. Required.
        :type body: ~azureiotcentral.models.Organization
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, organization_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Organization:
        """Create an organization in the application.

        Create an organization in the application.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, organization_id: str, body: Union[_models.Organization, IO], **kwargs: Any
    ) -> _models.Organization:
        """Create an organization in the application.

        Create an organization in the application.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Organization or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Organization]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Organization")

        request = build_organizations_create_request(
            organization_id=organization_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update(self, organization_id: str, body: JSON, **kwargs: Any) -> _models.Organization:
        """Update an organization in the application via patch.

        Update an organization in the application via patch.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization patch body. Required.
        :type body: JSON
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Organization]

        _json = self._serialize.body(body, "object")

        request = build_organizations_update_request(
            organization_id=organization_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, organization_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an organization.

        Delete an organization.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_organizations_remove_request(
            organization_id=organization_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class RolesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`roles` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.Role"]:
        """Get the list of roles in an application.

        Get the list of roles in an application.

        :return: An iterator like instance of Role
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.Role]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[RoleCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_roles_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("RoleCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, role_id: str, **kwargs: Any) -> _models.Role:
        """Get a role by ID.

        Get a role by ID.

        :param role_id: Unique ID for the role. Required.
        :type role_id: str
        :return: Role
        :rtype: ~azureiotcentral.models.Role
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Role]

        request = build_roles_get_request(
            role_id=role_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Role", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class UsersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.AzureIoTCentral`'s
        :attr:`users` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> Iterable["_models.User"]:
        """Get the list of users in an application.

        Get the list of users in an application.

        :return: An iterator like instance of User
        :rtype: ~azure.core.paging.ItemPaged[~azureiotcentral.models.User]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[UserCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_users_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("UserCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, user_id: str, **kwargs: Any) -> _models.User:
        """Get a user by ID.

        Get a user by ID.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.User]

        request = build_users_get_request(
            user_id=user_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("User", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    def create(
        self, user_id: str, body: _models.User, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.User:
        """Create a user in the application.

        Create a user in the application.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User body. Required.
        :type body: ~azureiotcentral.models.User
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(self, user_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any) -> _models.User:
        """Create a user in the application.

        Create a user in the application.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(self, user_id: str, body: Union[_models.User, IO], **kwargs: Any) -> _models.User:
        """Create a user in the application.

        Create a user in the application.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.User or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.User]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "User")

        request = build_users_create_request(
            user_id=user_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("User", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def update(self, user_id: str, body: JSON, **kwargs: Any) -> _models.User:
        """Update a user in the application via patch.

        Update a user in the application via patch.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User patch body. Required.
        :type body: JSON
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.User]

        _json = self._serialize.body(body, "object")

        request = build_users_update_request(
            user_id=user_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("User", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def remove(self, user_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a user.

        Delete a user.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_users_remove_request(
            user_id=user_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
