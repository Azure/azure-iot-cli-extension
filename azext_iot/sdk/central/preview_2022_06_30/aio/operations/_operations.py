# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
from urllib.parse import parse_qs, urljoin, urlparse

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models as _models
from ...models._models import (
    ApiTokenCollection,
    DashboardCollection,
    DestinationCollection,
    DeviceCollection,
    DeviceCommandCollection,
    DeviceGroupCollection,
    DeviceGroupDeviceCollection,
    DeviceTemplateCollection,
    EnrollmentGroupCollection,
    ExportCollection,
    JobCollection,
    JobDeviceStatusCollection,
    OrganizationCollection,
    RoleCollection,
    ScheduledJobCollection,
    UserCollection,
)
from ...operations._operations import (
    build_api_tokens_create_request,
    build_api_tokens_get_request,
    build_api_tokens_list_request,
    build_api_tokens_remove_request,
    build_dashboards_create_request,
    build_dashboards_get_request,
    build_dashboards_list_request,
    build_dashboards_remove_request,
    build_dashboards_update_request,
    build_destinations_create_request,
    build_destinations_get_request,
    build_destinations_list_exports_request,
    build_destinations_list_request,
    build_destinations_remove_request,
    build_destinations_update_request,
    build_device_groups_create_request,
    build_device_groups_get_devices_request,
    build_device_groups_get_request,
    build_device_groups_list_request,
    build_device_groups_remove_request,
    build_device_groups_update_request,
    build_device_templates_create_request,
    build_device_templates_get_request,
    build_device_templates_list_request,
    build_device_templates_remove_request,
    build_device_templates_update_request,
    build_devices_create_attestation_request,
    build_devices_create_relationship_request,
    build_devices_create_request,
    build_devices_get_attestation_request,
    build_devices_get_command_history_request,
    build_devices_get_component_command_history_request,
    build_devices_get_component_properties_request,
    build_devices_get_component_telemetry_value_request,
    build_devices_get_credentials_request,
    build_devices_get_module_command_history_request,
    build_devices_get_module_component_command_history_request,
    build_devices_get_module_component_properties_request,
    build_devices_get_module_component_telemetry_value_request,
    build_devices_get_module_properties_request,
    build_devices_get_module_telemetry_value_request,
    build_devices_get_properties_request,
    build_devices_get_relationship_request,
    build_devices_get_request,
    build_devices_get_telemetry_value_request,
    build_devices_list_components_request,
    build_devices_list_module_components_request,
    build_devices_list_modules_request,
    build_devices_list_relationships_request,
    build_devices_list_request,
    build_devices_remove_attestation_request,
    build_devices_remove_relationship_request,
    build_devices_remove_request,
    build_devices_replace_component_properties_request,
    build_devices_replace_module_component_properties_request,
    build_devices_replace_module_properties_request,
    build_devices_replace_properties_request,
    build_devices_run_command_request,
    build_devices_run_component_command_request,
    build_devices_run_module_command_request,
    build_devices_run_module_component_command_request,
    build_devices_update_attestation_request,
    build_devices_update_component_properties_request,
    build_devices_update_module_component_properties_request,
    build_devices_update_module_properties_request,
    build_devices_update_properties_request,
    build_devices_update_relationship_request,
    build_devices_update_request,
    build_enrollment_groups_create_request,
    build_enrollment_groups_create_x509_request,
    build_enrollment_groups_generate_verification_code_x509_request,
    build_enrollment_groups_get_request,
    build_enrollment_groups_get_x509_request,
    build_enrollment_groups_list_request,
    build_enrollment_groups_remove_request,
    build_enrollment_groups_remove_x509_request,
    build_enrollment_groups_update_request,
    build_enrollment_groups_verify_x509_request,
    build_exports_create_request,
    build_exports_get_request,
    build_exports_list_destinations_request,
    build_exports_list_request,
    build_exports_remove_request,
    build_exports_update_request,
    build_file_uploads_create_request,
    build_file_uploads_get_request,
    build_file_uploads_remove_request,
    build_file_uploads_update_request,
    build_jobs_create_request,
    build_jobs_get_devices_request,
    build_jobs_get_request,
    build_jobs_list_request,
    build_jobs_rerun_request,
    build_jobs_resume_request,
    build_jobs_stop_request,
    build_organizations_create_request,
    build_organizations_get_request,
    build_organizations_list_request,
    build_organizations_remove_request,
    build_organizations_update_request,
    build_query_run_request,
    build_roles_get_request,
    build_roles_list_request,
    build_scheduled_jobs_create_request,
    build_scheduled_jobs_get_request,
    build_scheduled_jobs_list_jobs_request,
    build_scheduled_jobs_list_request,
    build_scheduled_jobs_remove_request,
    build_scheduled_jobs_update_request,
    build_users_create_request,
    build_users_get_request,
    build_users_list_request,
    build_users_remove_request,
    build_users_update_request,
)

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class ApiTokensOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`api_tokens` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.ApiToken"]:
        """Get the list of API tokens in an application. The token value will never be returned for
        security reasons.

        Get the list of API tokens in an application. The token value will never be returned for
        security reasons.

        :return: An iterator like instance of ApiToken
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.ApiToken]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ApiTokenCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_api_tokens_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ApiTokenCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, token_id: str, **kwargs: Any) -> _models.ApiToken:
        """Get an API token by ID.

        Get an API token by ID.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ApiToken]

        request = build_api_tokens_get_request(
            token_id=token_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ApiToken", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, token_id: str, body: _models.ApiToken, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ApiToken:
        """Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :param body: API token body. Required.
        :type body: ~azureiotcentral.models.ApiToken
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, token_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ApiToken:
        """Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :param body: API token body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, token_id: str, body: Union[_models.ApiToken, IO], **kwargs: Any) -> _models.ApiToken:
        """Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        Create a new API token in the application to use in the IoT Central public API. The token value
        will be returned in the response, and won't be returned again in subsequent requests.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :param body: API token body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.ApiToken or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ApiToken
        :rtype: ~azureiotcentral.models.ApiToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ApiToken]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ApiToken")

        request = build_api_tokens_create_request(
            token_id=token_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ApiToken", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(self, token_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an API token.

        Delete an API token.

        :param token_id: Unique ID for the API token. Required.
        :type token_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_api_tokens_remove_request(
            token_id=token_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DashboardsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`dashboards` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Dashboard"]:
        """Get the list of dashboards in an application.

        Get the list of dashboards in an application.

        :return: An iterator like instance of Dashboard
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Dashboard]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DashboardCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_dashboards_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DashboardCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, dashboard_id: str, **kwargs: Any) -> _models.Dashboard:
        """Get a dashboard by ID.

        Get a dashboard by ID.

        :param dashboard_id: Unique ID for the dashboard. Required.
        :type dashboard_id: str
        :return: Dashboard
        :rtype: ~azureiotcentral.models.Dashboard
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Dashboard]

        request = build_dashboards_get_request(
            dashboard_id=dashboard_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Dashboard", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, dashboard_id: str, body: _models.Dashboard, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Dashboard:
        """Create a dashboard.

        Create a dashboard.

        :param dashboard_id: Unique ID for the dashboard. Required.
        :type dashboard_id: str
        :param body: Dashboard definition. Required.
        :type body: ~azureiotcentral.models.Dashboard
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Dashboard
        :rtype: ~azureiotcentral.models.Dashboard
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, dashboard_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Dashboard:
        """Create a dashboard.

        Create a dashboard.

        :param dashboard_id: Unique ID for the dashboard. Required.
        :type dashboard_id: str
        :param body: Dashboard definition. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Dashboard
        :rtype: ~azureiotcentral.models.Dashboard
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, dashboard_id: str, body: Union[_models.Dashboard, IO], **kwargs: Any) -> _models.Dashboard:
        """Create a dashboard.

        Create a dashboard.

        :param dashboard_id: Unique ID for the dashboard. Required.
        :type dashboard_id: str
        :param body: Dashboard definition. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Dashboard or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Dashboard
        :rtype: ~azureiotcentral.models.Dashboard
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Dashboard]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Dashboard")

        request = build_dashboards_create_request(
            dashboard_id=dashboard_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Dashboard", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, dashboard_id: str, body: JSON, **kwargs: Any) -> _models.Dashboard:
        """Update a dashboard.

        Update a dashboard.

        :param dashboard_id: Unique ID for the dashboard. Required.
        :type dashboard_id: str
        :param body: Dashboard definition. Required.
        :type body: JSON
        :return: Dashboard
        :rtype: ~azureiotcentral.models.Dashboard
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Dashboard]

        _json = self._serialize.body(body, "object")

        request = build_dashboards_update_request(
            dashboard_id=dashboard_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Dashboard", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(self, dashboard_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a dashboard.

        Delete a dashboard.

        :param dashboard_id: Unique ID for the dashboard. Required.
        :type dashboard_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_dashboards_remove_request(
            dashboard_id=dashboard_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DestinationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`destinations` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Destination"]:
        """Get the list of destinations in an application.

        Get the list of destinations in an application.

        :return: An iterator like instance of Destination
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Destination]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DestinationCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_destinations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DestinationCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, destination_id: str, **kwargs: Any) -> _models.Destination:
        """Get a destination by ID.

        Get a destination by ID.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :return: Destination
        :rtype: ~azureiotcentral.models.Destination
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Destination]

        request = build_destinations_get_request(
            destination_id=destination_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Destination", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, destination_id: str, body: _models.Destination, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Destination:
        """Create or update a destination.

        Create or update a definition for where to send data.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :param body: Destination body. Required.
        :type body: ~azureiotcentral.models.Destination
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Destination
        :rtype: ~azureiotcentral.models.Destination
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, destination_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Destination:
        """Create or update a destination.

        Create or update a definition for where to send data.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :param body: Destination body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Destination
        :rtype: ~azureiotcentral.models.Destination
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, destination_id: str, body: Union[_models.Destination, IO], **kwargs: Any
    ) -> _models.Destination:
        """Create or update a destination.

        Create or update a definition for where to send data.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :param body: Destination body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Destination or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Destination
        :rtype: ~azureiotcentral.models.Destination
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Destination]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Destination")

        request = build_destinations_create_request(
            destination_id=destination_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Destination", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, destination_id: str, body: JSON, **kwargs: Any) -> _models.Destination:
        """Patch a destination.

        Perform an incremental update to a destination.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :param body: Destination patch body. Required.
        :type body: JSON
        :return: Destination
        :rtype: ~azureiotcentral.models.Destination
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Destination]

        _json = self._serialize.body(body, "object")

        request = build_destinations_update_request(
            destination_id=destination_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Destination", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(  # pylint: disable=inconsistent-return-statements
        self, destination_id: str, **kwargs: Any
    ) -> None:
        """Delete a destination.

        Delete a destination.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_destinations_remove_request(
            destination_id=destination_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list_exports(self, destination_id: str, **kwargs: Any) -> AsyncIterable["_models.Export"]:
        """List all exports connected to the given destination.

        List all exports connected to the given destination.

        :param destination_id: Unique ID for the destination. Required.
        :type destination_id: str
        :return: An iterator like instance of Export
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Export]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ExportCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_destinations_list_exports_request(
                    destination_id=destination_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ExportCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class ExportsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`exports` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Export"]:
        """Get the list of exports in an application.

        Get the list of exports in an application.

        :return: An iterator like instance of Export
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Export]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ExportCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_exports_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ExportCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, export_id: str, **kwargs: Any) -> _models.Export:
        """Get an export by ID.

        Get an export by ID.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :return: Export
        :rtype: ~azureiotcentral.models.Export
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]

        request = build_exports_get_request(
            export_id=export_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Export", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, export_id: str, body: _models.Export, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Export:
        """Create or update an export.

        Create or update a definition for exporting data. Also used to connect or disconnect an export
        from destinations.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :param body: Export body. Required.
        :type body: ~azureiotcentral.models.Export
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Export
        :rtype: ~azureiotcentral.models.Export
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, export_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Export:
        """Create or update an export.

        Create or update a definition for exporting data. Also used to connect or disconnect an export
        from destinations.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :param body: Export body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Export
        :rtype: ~azureiotcentral.models.Export
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, export_id: str, body: Union[_models.Export, IO], **kwargs: Any) -> _models.Export:
        """Create or update an export.

        Create or update a definition for exporting data. Also used to connect or disconnect an export
        from destinations.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :param body: Export body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Export or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Export
        :rtype: ~azureiotcentral.models.Export
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Export")

        request = build_exports_create_request(
            export_id=export_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Export", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, export_id: str, body: JSON, **kwargs: Any) -> _models.Export:
        """Patch an export.

        Perform an incremental update to an export.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :param body: Export patch body. Required.
        :type body: JSON
        :return: Export
        :rtype: ~azureiotcentral.models.Export
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Export]

        _json = self._serialize.body(body, "object")

        request = build_exports_update_request(
            export_id=export_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Export", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(self, export_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an export.

        Delete an export.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_exports_remove_request(
            export_id=export_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list_destinations(self, export_id: str, **kwargs: Any) -> AsyncIterable["_models.Destination"]:
        """List all destinations connected to the given export.

        List all destinations connected to the given export.

        :param export_id: Unique ID for the export. Required.
        :type export_id: str
        :return: An iterator like instance of Destination
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Destination]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DestinationCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_exports_list_destinations_request(
                    export_id=export_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DestinationCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DeviceGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`device_groups` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, orderby: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable["_models.DeviceGroup"]:
        """Get the list of device groups in an application.

        Get the list of device groups in an application.

        :keyword filter: An expression on the resource type that selects the resources to be returned.
         Default value is None.
        :paramtype filter: str
        :keyword top: The maximum number of resources to return from the collection. Default value is
         None.
        :paramtype top: int
        :keyword orderby: An expression that specify the order of the returned resources. Default value
         is None.
        :paramtype orderby: str
        :return: An iterator like instance of DeviceGroup
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.DeviceGroup]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceGroupCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_device_groups_list_request(
                    filter=filter,
                    top=top,
                    orderby=orderby,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceGroupCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, device_group_id: str, **kwargs: Any) -> _models.DeviceGroup:
        """Get the device group by ID.

        Get the device group by ID.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceGroup]

        request = build_device_groups_get_request(
            device_group_id=device_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, device_group_id: str, body: _models.DeviceGroup, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceGroup:
        """Create or update a device group.

        Create or update a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group body. Required.
        :type body: ~azureiotcentral.models.DeviceGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, device_group_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceGroup:
        """Create or update a device group.

        Create or update a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, device_group_id: str, body: Union[_models.DeviceGroup, IO], **kwargs: Any
    ) -> _models.DeviceGroup:
        """Create or update a device group.

        Create or update a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceGroup or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceGroup]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceGroup")

        request = build_device_groups_create_request(
            device_group_id=device_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, device_group_id: str, body: JSON, **kwargs: Any) -> _models.DeviceGroup:
        """Update a device group via patch.

        Update an existing device group by ID.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :param body: Device group patch body. Required.
        :type body: JSON
        :return: DeviceGroup
        :rtype: ~azureiotcentral.models.DeviceGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceGroup]

        _json = self._serialize.body(body, "object")

        request = build_device_groups_update_request(
            device_group_id=device_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(  # pylint: disable=inconsistent-return-statements
        self, device_group_id: str, **kwargs: Any
    ) -> None:
        """Delete a device group.

        Delete a device group.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_device_groups_remove_request(
            device_group_id=device_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_devices(
        self, device_group_id: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncIterable["_models.Device"]:
        """Get the devices of a device group.

        Get the list of devices by device group ID.

        :param device_group_id: Unique ID for the device group. Required.
        :type device_group_id: str
        :keyword top: The maximum number of resources to return from the collection. Default value is
         None.
        :paramtype top: int
        :return: An iterator like instance of Device
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Device]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceGroupDeviceCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_device_groups_get_devices_request(
                    device_group_id=device_group_id,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceGroupDeviceCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DeviceTemplatesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`device_templates` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, orderby: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable["_models.DeviceTemplate"]:
        """Get the list of device templates in an application with basic ODATA support ($top, $filter,
        $orderby), `more details <https://aka.ms/iotcentralodatasupport>`_.

        Get the list of device templates in an application with basic ODATA support ($top, $filter,
        $orderby), `more details <https://aka.ms/iotcentralodatasupport>`_.

        :keyword filter: An expression on the resource type that selects the resources to be returned.
         Default value is None.
        :paramtype filter: str
        :keyword top: The maximum number of resources to return from the collection. Default value is
         None.
        :paramtype top: int
        :keyword orderby: An expression that specify the order of the returned resources. Default value
         is None.
        :paramtype orderby: str
        :return: An iterator like instance of DeviceTemplate
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.DeviceTemplate]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceTemplateCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_device_templates_list_request(
                    filter=filter,
                    top=top,
                    orderby=orderby,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceTemplateCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, device_template_id: str, **kwargs: Any) -> _models.DeviceTemplate:
        """Get a device template by ID.

        Get a device template by ID.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTemplate]

        request = build_device_templates_get_request(
            device_template_id=device_template_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTemplate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self,
        device_template_id: str,
        body: _models.DeviceTemplate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceTemplate:
        """Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template body. Required.
        :type body: ~azureiotcentral.models.DeviceTemplate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, device_template_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceTemplate:
        """Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, device_template_id: str, body: Union[_models.DeviceTemplate, IO], **kwargs: Any
    ) -> _models.DeviceTemplate:
        """Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        Publish a new device template. Default views will be automatically generated for new device
        templates created this way.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceTemplate or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTemplate]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceTemplate")

        request = build_device_templates_create_request(
            device_template_id=device_template_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTemplate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, device_template_id: str, body: JSON, **kwargs: Any) -> _models.DeviceTemplate:
        """Update the cloud properties and overrides of an existing device template via patch.

        Update the cloud properties and overrides of an existing device template via patch.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :param body: Device template patch body. Required.
        :type body: JSON
        :return: DeviceTemplate
        :rtype: ~azureiotcentral.models.DeviceTemplate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTemplate]

        _json = self._serialize.body(body, "object")

        request = build_device_templates_update_request(
            device_template_id=device_template_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTemplate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(  # pylint: disable=inconsistent-return-statements
        self, device_template_id: str, **kwargs: Any
    ) -> None:
        """Delete a device template.

        Delete an existing device template by device ID.

        :param device_template_id: Unique `Digital Twin Model Identifier
         <https://github.com/Azure/opendigitaltwins-dtdl/blob/master/DTDL/v2/dtdlv2.md#digital-twin-model-identifier>`_
         of the device template. Required.
        :type device_template_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_device_templates_remove_request(
            device_template_id=device_template_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class DevicesOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`devices` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, orderby: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable["_models.Device"]:
        """Get the list of devices in an application with basic ODATA support ($top, $filter, $orderby),
        `more details <https://aka.ms/iotcentralodatasupport>`_.

        Get the list of devices in an application with basic ODATA support ($top, $filter, $orderby),
        `more details <https://aka.ms/iotcentralodatasupport>`_.

        :keyword filter: An expression on the resource type that selects the resources to be returned.
         Default value is None.
        :paramtype filter: str
        :keyword top: The maximum number of resources to return from the collection. Default value is
         None.
        :paramtype top: int
        :keyword orderby: An expression that specify the order of the returned resources. Default value
         is None.
        :paramtype orderby: str
        :return: An iterator like instance of Device
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Device]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_list_request(
                    filter=filter,
                    top=top,
                    orderby=orderby,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, device_id: str, **kwargs: Any) -> _models.Device:
        """Get a device by ID.

        Get details about an existing device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Device]

        request = build_devices_get_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Device", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, device_id: str, body: _models.Device, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Device:
        """Create or update a device.

        Create a new device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device body. Required.
        :type body: ~azureiotcentral.models.Device
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, device_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Device:
        """Create or update a device.

        Create a new device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, device_id: str, body: Union[_models.Device, IO], **kwargs: Any) -> _models.Device:
        """Create or update a device.

        Create a new device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Device or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Device]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Device")

        request = build_devices_create_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Device", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, device_id: str, body: JSON, **kwargs: Any) -> _models.Device:
        """Update a device via patch.

        Update an existing device by ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device patch body. Required.
        :type body: JSON
        :return: Device
        :rtype: ~azureiotcentral.models.Device
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Device]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Device", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(self, device_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a device.

        Delete an existing device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_devices_remove_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_attestation(self, device_id: str, **kwargs: Any) -> _models.Attestation:
        """Get device attestation.

        Get device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Attestation]

        request = build_devices_get_attestation_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Attestation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_attestation(
        self, device_id: str, body: _models.Attestation, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Attestation:
        """Create an individual device attestation.

        Create an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation body. Required.
        :type body: ~azureiotcentral.models.Attestation
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_attestation(
        self, device_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Attestation:
        """Create an individual device attestation.

        Create an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_attestation(
        self, device_id: str, body: Union[_models.Attestation, IO], **kwargs: Any
    ) -> _models.Attestation:
        """Create an individual device attestation.

        Create an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Attestation or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Attestation]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Attestation")

        request = build_devices_create_attestation_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Attestation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update_attestation(self, device_id: str, body: JSON, **kwargs: Any) -> _models.Attestation:
        """Update an individual device attestation via patch.

        Update an individual device attestation via patch.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Individual device attestation patch body. Required.
        :type body: JSON
        :return: Attestation
        :rtype: ~azureiotcentral.models.Attestation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Attestation]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_attestation_request(
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Attestation", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove_attestation(  # pylint: disable=inconsistent-return-statements
        self, device_id: str, **kwargs: Any
    ) -> None:
        """Remove an individual device attestation.

        Remove an individual device attestation.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_devices_remove_attestation_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_command_history(
        self, device_id: str, command_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.DeviceCommand"]:
        """Get device command history.

        Get device command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_command_history_request(
                    device_id=device_id,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def run_command(
        self,
        device_id: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a device command.

        Run a command on a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def run_command(
        self, device_id: str, command_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a device command.

        Run a command on a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def run_command(
        self, device_id: str, command_name: str, body: Union[_models.DeviceCommand, IO], **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a device command.

        Run a command on a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_command_request(
            device_id=device_id,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_components(self, device_id: str, **kwargs: Any) -> _models.Collection:
        """List the components present in a device.

        List the components present in a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Collection
        :rtype: ~azureiotcentral.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Collection]

        request = build_devices_list_components_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_component_command_history(
        self, device_id: str, component_name: str, command_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.DeviceCommand"]:
        """Get component command history.

        Get component command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_component_command_history_request(
                    device_id=device_id,
                    component_name=component_name,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def run_component_command(
        self,
        device_id: str,
        component_name: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a component command.

        Run a command on a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def run_component_command(
        self,
        device_id: str,
        component_name: str,
        command_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a component command.

        Run a command on a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def run_component_command(
        self,
        device_id: str,
        component_name: str,
        command_name: str,
        body: Union[_models.DeviceCommand, IO],
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a component command.

        Run a command on a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_component_command_request(
            device_id=device_id,
            component_name=component_name,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_component_properties(
        self, device_id: str, component_name: str, *, unmodeled: bool = False, **kwargs: Any
    ) -> Dict[str, Any]:
        """Get device properties for a specific component.

        Get device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_component_properties_request(
            device_id=device_id,
            component_name=component_name,
            unmodeled=unmodeled,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def replace_component_properties(
        self,
        device_id: str,
        component_name: str,
        body: Dict[str, Any],
        *,
        unmodeled: bool = False,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties for a specific component.

        Replace device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties. Required.
        :type body: dict[str, any]
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def replace_component_properties(
        self,
        device_id: str,
        component_name: str,
        body: IO,
        *,
        unmodeled: bool = False,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties for a specific component.

        Replace device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties. Required.
        :type body: IO
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def replace_component_properties(
        self,
        device_id: str,
        component_name: str,
        body: Union[Dict[str, Any], IO],
        *,
        unmodeled: bool = False,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties for a specific component.

        Replace device properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_component_properties_request(
            device_id=device_id,
            component_name=component_name,
            unmodeled=unmodeled,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update_component_properties(
        self, device_id: str, component_name: str, body: JSON, *, unmodeled: bool = False, **kwargs: Any
    ) -> Dict[str, Any]:
        """Update device properties for a specific component via patch.

        Update device properties for a specific component via patch.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Device properties patch. Required.
        :type body: JSON
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_component_properties_request(
            device_id=device_id,
            component_name=component_name,
            unmodeled=unmodeled,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_component_telemetry_value(
        self, device_id: str, component_name: str, telemetry_name: str, **kwargs: Any
    ) -> _models.DeviceTelemetry:
        """Get component telemetry value.

        Get the last telemetry value from a component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_component_telemetry_value_request(
            device_id=device_id,
            component_name=component_name,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_credentials(self, device_id: str, **kwargs: Any) -> _models.DeviceCredentials:
        """Get device credentials.

        Get device credentials.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: DeviceCredentials
        :rtype: ~azureiotcentral.models.DeviceCredentials
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCredentials]

        request = build_devices_get_credentials_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCredentials", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_modules(self, device_id: str, **kwargs: Any) -> _models.Collection:
        """List the modules present in a device.

        List the modules present in a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: Collection
        :rtype: ~azureiotcentral.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Collection]

        request = build_devices_list_modules_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_command_history(
        self, device_id: str, module_name: str, command_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.DeviceCommand"]:
        """Get module command history.

        Get module command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_module_command_history_request(
                    device_id=device_id,
                    module_name=module_name,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def run_module_command(
        self,
        device_id: str,
        module_name: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def run_module_command(
        self,
        device_id: str,
        module_name: str,
        command_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def run_module_command(
        self, device_id: str, module_name: str, command_name: str, body: Union[_models.DeviceCommand, IO], **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_module_command_request(
            device_id=device_id,
            module_name=module_name,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_module_components(self, device_id: str, module_name: str, **kwargs: Any) -> _models.Collection:
        """List the components present in a module.

        List the components present in a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :return: Collection
        :rtype: ~azureiotcentral.models.Collection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Collection]

        request = build_devices_list_module_components_request(
            device_id=device_id,
            module_name=module_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Collection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_module_component_command_history(
        self, device_id: str, module_name: str, component_name: str, command_name: str, **kwargs: Any
    ) -> AsyncIterable["_models.DeviceCommand"]:
        """Get module component command history.

        Get module component command history.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :return: An iterator like instance of DeviceCommand
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.DeviceCommand]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[DeviceCommandCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_get_module_component_command_history_request(
                    device_id=device_id,
                    module_name=module_name,
                    component_name=component_name,
                    command_name=command_name,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DeviceCommandCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def run_module_component_command(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        command_name: str,
        body: _models.DeviceCommand,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module component command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: ~azureiotcentral.models.DeviceCommand
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def run_module_component_command(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        command_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module component command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def run_module_component_command(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        command_name: str,
        body: Union[_models.DeviceCommand, IO],
        **kwargs: Any
    ) -> _models.DeviceCommand:
        """Run a module component command.

        Run a command on a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param command_name: Name of this device command. Required.
        :type command_name: str
        :param body: Device command body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceCommand or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceCommand
        :rtype: ~azureiotcentral.models.DeviceCommand
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceCommand]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceCommand")

        request = build_devices_run_module_component_command_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            command_name=command_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceCommand", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_module_component_properties(
        self, device_id: str, module_name: str, component_name: str, **kwargs: Any
    ) -> Dict[str, Any]:
        """Get module properties for a specific component.

        Get module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_module_component_properties_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def replace_module_component_properties(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        body: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties for a specific component.

        Replace module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties. Required.
        :type body: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def replace_module_component_properties(
        self,
        device_id: str,
        module_name: str,
        component_name: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties for a specific component.

        Replace module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def replace_module_component_properties(
        self, device_id: str, module_name: str, component_name: str, body: Union[Dict[str, Any], IO], **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties for a specific component.

        Replace module properties for a specific component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_module_component_properties_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update_module_component_properties(
        self, device_id: str, module_name: str, component_name: str, body: JSON, **kwargs: Any
    ) -> Dict[str, Any]:
        """Update module properties for a specific component via patch.

        Update module properties for a specific component via patch.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param body: Module properties patch. Required.
        :type body: JSON
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_module_component_properties_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_module_component_telemetry_value(
        self, device_id: str, module_name: str, component_name: str, telemetry_name: str, **kwargs: Any
    ) -> _models.DeviceTelemetry:
        """Get module component telemetry value.

        Get the last telemetry value from a module component.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param component_name: Name of the device component. Required.
        :type component_name: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_module_component_telemetry_value_request(
            device_id=device_id,
            module_name=module_name,
            component_name=component_name,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_module_properties(self, device_id: str, module_name: str, **kwargs: Any) -> Dict[str, Any]:
        """Get module properties.

        Get all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_module_properties_request(
            device_id=device_id,
            module_name=module_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def replace_module_properties(
        self,
        device_id: str,
        module_name: str,
        body: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties.

        Replace all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties. Required.
        :type body: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def replace_module_properties(
        self, device_id: str, module_name: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties.

        Replace all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def replace_module_properties(
        self, device_id: str, module_name: str, body: Union[Dict[str, Any], IO], **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace module properties.

        Replace all property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_module_properties_request(
            device_id=device_id,
            module_name=module_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update_module_properties(
        self, device_id: str, module_name: str, body: JSON, **kwargs: Any
    ) -> Dict[str, Any]:
        """Update module properties via patch.

        Update property values of a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param body: Module properties patch. Required.
        :type body: JSON
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_module_properties_request(
            device_id=device_id,
            module_name=module_name,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_module_telemetry_value(
        self, device_id: str, module_name: str, telemetry_name: str, **kwargs: Any
    ) -> _models.DeviceTelemetry:
        """Get module telemetry value.

        Get the last telemetry value from a module.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param module_name: Name of the device module. Required.
        :type module_name: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_module_telemetry_value_request(
            device_id=device_id,
            module_name=module_name,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_properties(self, device_id: str, *, unmodeled: bool = False, **kwargs: Any) -> Dict[str, Any]:
        """Get device properties.

        Get all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        request = build_devices_get_properties_request(
            device_id=device_id,
            unmodeled=unmodeled,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def replace_properties(
        self,
        device_id: str,
        body: Dict[str, Any],
        *,
        unmodeled: bool = False,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties.

        Replace all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties. Required.
        :type body: dict[str, any]
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def replace_properties(
        self,
        device_id: str,
        body: IO,
        *,
        unmodeled: bool = False,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties.

        Replace all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties. Required.
        :type body: IO
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def replace_properties(
        self, device_id: str, body: Union[Dict[str, Any], IO], *, unmodeled: bool = False, **kwargs: Any
    ) -> Dict[str, Any]:
        """Replace device properties.

        Replace all property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties. Is either a dict type or a IO type. Required.
        :type body: dict[str, any] or IO
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "{object}")

        request = build_devices_replace_properties_request(
            device_id=device_id,
            unmodeled=unmodeled,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update_properties(
        self, device_id: str, body: JSON, *, unmodeled: bool = False, **kwargs: Any
    ) -> Dict[str, Any]:
        """Update device properties via patch.

        Update property values of a device by device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param body: Device properties patch. Required.
        :type body: JSON
        :keyword unmodeled: The query parameter for supporting unmodeled properties. Default value is
         False.
        :paramtype unmodeled: bool
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_properties_request(
            device_id=device_id,
            unmodeled=unmodeled,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("{object}", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def list_relationships(self, device_id: str, **kwargs: Any) -> _models.DeviceRelationshipCollection:
        """Given the ID for an upstream device, will return the upstream and the downstream relationships
        associated with that gateway. These downstream relationships are only those associated with the
        direct downstream level (they dont work recursively).

        List all relationships based on device ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :return: DeviceRelationshipCollection
        :rtype: ~azureiotcentral.models.DeviceRelationshipCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceRelationshipCollection]

        request = build_devices_list_relationships_request(
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceRelationshipCollection", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_relationship(self, device_id: str, relationship_id: str, **kwargs: Any) -> _models.DeviceRelationship:
        """Given the ID for a device and a relationship ID associated with this device, get the details of
        the relationship.

        Get device relationship by ID.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param relationship_id: Unique ID of a relationship between devices. Required.
        :type relationship_id: str
        :return: DeviceRelationship
        :rtype: ~azureiotcentral.models.DeviceRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceRelationship]

        request = build_devices_get_relationship_request(
            device_id=device_id,
            relationship_id=relationship_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceRelationship", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_relationship(
        self,
        device_id: str,
        relationship_id: str,
        body: _models.DeviceRelationship,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DeviceRelationship:
        """Given the ID for a device and a relationship ID associated with this device, create a new
        relationship for between the given device and a second device specified in the body.

        Create a device relationship.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param relationship_id: Unique ID of a relationship between devices. Required.
        :type relationship_id: str
        :param body: Device relationship body. Required.
        :type body: ~azureiotcentral.models.DeviceRelationship
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceRelationship
        :rtype: ~azureiotcentral.models.DeviceRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_relationship(
        self, device_id: str, relationship_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DeviceRelationship:
        """Given the ID for a device and a relationship ID associated with this device, create a new
        relationship for between the given device and a second device specified in the body.

        Create a device relationship.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param relationship_id: Unique ID of a relationship between devices. Required.
        :type relationship_id: str
        :param body: Device relationship body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DeviceRelationship
        :rtype: ~azureiotcentral.models.DeviceRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_relationship(
        self, device_id: str, relationship_id: str, body: Union[_models.DeviceRelationship, IO], **kwargs: Any
    ) -> _models.DeviceRelationship:
        """Given the ID for a device and a relationship ID associated with this device, create a new
        relationship for between the given device and a second device specified in the body.

        Create a device relationship.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param relationship_id: Unique ID of a relationship between devices. Required.
        :type relationship_id: str
        :param body: Device relationship body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.DeviceRelationship or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: DeviceRelationship
        :rtype: ~azureiotcentral.models.DeviceRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceRelationship]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceRelationship")

        request = build_devices_create_relationship_request(
            device_id=device_id,
            relationship_id=relationship_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceRelationship", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update_relationship(
        self, device_id: str, relationship_id: str, body: JSON, **kwargs: Any
    ) -> _models.DeviceRelationship:
        """Patch a given relationship given the relationship ID and a given device ID.

        Update device relationship.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param relationship_id: Unique ID of a relationship between devices. Required.
        :type relationship_id: str
        :param body: Device relationship patch body. Required.
        :type body: JSON
        :return: DeviceRelationship
        :rtype: ~azureiotcentral.models.DeviceRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceRelationship]

        _json = self._serialize.body(body, "object")

        request = build_devices_update_relationship_request(
            device_id=device_id,
            relationship_id=relationship_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceRelationship", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove_relationship(  # pylint: disable=inconsistent-return-statements
        self, device_id: str, relationship_id: str, **kwargs: Any
    ) -> None:
        """Given the ID for a device and an associated relationship ID, delete the relationship. The given
        device ID can be that of the upstream or downstream device.

        Delete a device relationship.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param relationship_id: Unique ID of a relationship between devices. Required.
        :type relationship_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_devices_remove_relationship_request(
            device_id=device_id,
            relationship_id=relationship_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_telemetry_value(self, device_id: str, telemetry_name: str, **kwargs: Any) -> _models.DeviceTelemetry:
        """Get device telemetry value.

        Get the last telemetry value from a device.

        :param device_id: Unique ID of the device. Required.
        :type device_id: str
        :param telemetry_name: Name of this device telemetry. Required.
        :type telemetry_name: str
        :return: DeviceTelemetry
        :rtype: ~azureiotcentral.models.DeviceTelemetry
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.DeviceTelemetry]

        request = build_devices_get_telemetry_value_request(
            device_id=device_id,
            telemetry_name=telemetry_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("DeviceTelemetry", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class EnrollmentGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`enrollment_groups` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.EnrollmentGroup"]:
        """Get the list of enrollment groups in an application.

        Get the list of enrollment groups in an application.

        :return: An iterator like instance of EnrollmentGroup
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.EnrollmentGroup]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[EnrollmentGroupCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_enrollment_groups_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("EnrollmentGroupCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, enrollment_group_id: str, **kwargs: Any) -> _models.EnrollmentGroup:
        """Get an enrollment group by ID.

        Get details about an enrollment group by ID.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :return: EnrollmentGroup
        :rtype: ~azureiotcentral.models.EnrollmentGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.EnrollmentGroup]

        request = build_enrollment_groups_get_request(
            enrollment_group_id=enrollment_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("EnrollmentGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self,
        enrollment_group_id: str,
        body: _models.EnrollmentGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EnrollmentGroup:
        """Create an enrollment group.

        Create an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param body: Enrollment group body. Required.
        :type body: ~azureiotcentral.models.EnrollmentGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: EnrollmentGroup
        :rtype: ~azureiotcentral.models.EnrollmentGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, enrollment_group_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.EnrollmentGroup:
        """Create an enrollment group.

        Create an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param body: Enrollment group body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: EnrollmentGroup
        :rtype: ~azureiotcentral.models.EnrollmentGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, enrollment_group_id: str, body: Union[_models.EnrollmentGroup, IO], **kwargs: Any
    ) -> _models.EnrollmentGroup:
        """Create an enrollment group.

        Create an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param body: Enrollment group body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.EnrollmentGroup or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: EnrollmentGroup
        :rtype: ~azureiotcentral.models.EnrollmentGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.EnrollmentGroup]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "EnrollmentGroup")

        request = build_enrollment_groups_create_request(
            enrollment_group_id=enrollment_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("EnrollmentGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, enrollment_group_id: str, body: JSON, **kwargs: Any) -> _models.EnrollmentGroup:
        """Update an enrollment group.

        Update an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param body: Enrollment group patch body. Required.
        :type body: JSON
        :return: EnrollmentGroup
        :rtype: ~azureiotcentral.models.EnrollmentGroup
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", "application/merge-patch+json")
        )  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.EnrollmentGroup]

        _json = self._serialize.body(body, "object")

        request = build_enrollment_groups_update_request(
            enrollment_group_id=enrollment_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("EnrollmentGroup", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(  # pylint: disable=inconsistent-return-statements
        self, enrollment_group_id: str, **kwargs: Any
    ) -> None:
        """Delete an enrollment group.

        Delete an enrollment group by ID.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_enrollment_groups_remove_request(
            enrollment_group_id=enrollment_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get_x509(
        self, enrollment_group_id: str, entry: Union[str, "_models.CertificateEntry"], **kwargs: Any
    ) -> _models.SigningX509Certificate:
        """Get the primary or secondary x509 certificate of an enrollment group.

        Get details about the primary or secondary x509 certificate of an enrollment group, if it
        exists.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :return: SigningX509Certificate
        :rtype: ~azureiotcentral.models.SigningX509Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SigningX509Certificate]

        request = build_enrollment_groups_get_x509_request(
            enrollment_group_id=enrollment_group_id,
            entry=entry,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("SigningX509Certificate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_x509(
        self,
        enrollment_group_id: str,
        entry: Union[str, "_models.CertificateEntry"],
        body: _models.SigningX509Certificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SigningX509Certificate:
        """Sets the primary or secondary x509 certificate of an enrollment group.

        Sets the primary or secondary x509 certificate of an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :param body: Certificate definition. Required.
        :type body: ~azureiotcentral.models.SigningX509Certificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SigningX509Certificate
        :rtype: ~azureiotcentral.models.SigningX509Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_x509(
        self,
        enrollment_group_id: str,
        entry: Union[str, "_models.CertificateEntry"],
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SigningX509Certificate:
        """Sets the primary or secondary x509 certificate of an enrollment group.

        Sets the primary or secondary x509 certificate of an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :param body: Certificate definition. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SigningX509Certificate
        :rtype: ~azureiotcentral.models.SigningX509Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_x509(
        self,
        enrollment_group_id: str,
        entry: Union[str, "_models.CertificateEntry"],
        body: Union[_models.SigningX509Certificate, IO],
        **kwargs: Any
    ) -> _models.SigningX509Certificate:
        """Sets the primary or secondary x509 certificate of an enrollment group.

        Sets the primary or secondary x509 certificate of an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :param body: Certificate definition. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.SigningX509Certificate or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: SigningX509Certificate
        :rtype: ~azureiotcentral.models.SigningX509Certificate
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.SigningX509Certificate]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "SigningX509Certificate")

        request = build_enrollment_groups_create_x509_request(
            enrollment_group_id=enrollment_group_id,
            entry=entry,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("SigningX509Certificate", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove_x509(  # pylint: disable=inconsistent-return-statements
        self, enrollment_group_id: str, entry: Union[str, "_models.CertificateEntry"], **kwargs: Any
    ) -> None:
        """Removes the primary or secondary x509 certificate of an enrollment group.

        Removes the primary or secondary x509 certificate of an enrollment group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_enrollment_groups_remove_x509_request(
            enrollment_group_id=enrollment_group_id,
            entry=entry,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def generate_verification_code_x509(
        self, enrollment_group_id: str, entry: Union[str, "_models.CertificateEntry"], **kwargs: Any
    ) -> _models.X509VerificationCode:
        """Generate a verification code for the primary or secondary x509 certificate of an enrollment
        group.

        Generate a verification code for the primary or secondary x509 certificate of an enrollment
        group.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :return: X509VerificationCode
        :rtype: ~azureiotcentral.models.X509VerificationCode
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.X509VerificationCode]

        request = build_enrollment_groups_generate_verification_code_x509_request(
            enrollment_group_id=enrollment_group_id,
            entry=entry,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("X509VerificationCode", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def verify_x509(  # pylint: disable=inconsistent-return-statements
        self,
        enrollment_group_id: str,
        entry: Union[str, "_models.CertificateEntry"],
        body: _models.X509VerificationCertificate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Verify the primary or secondary x509 certificate of an enrollment group.

        Verify the primary or secondary x509 certificate of an enrollment group by providing a
        certificate with the signed verification code.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :param body: Certificate for the signed verification code. Required.
        :type body: ~azureiotcentral.models.X509VerificationCertificate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def verify_x509(  # pylint: disable=inconsistent-return-statements
        self,
        enrollment_group_id: str,
        entry: Union[str, "_models.CertificateEntry"],
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Verify the primary or secondary x509 certificate of an enrollment group.

        Verify the primary or secondary x509 certificate of an enrollment group by providing a
        certificate with the signed verification code.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :param body: Certificate for the signed verification code. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def verify_x509(  # pylint: disable=inconsistent-return-statements
        self,
        enrollment_group_id: str,
        entry: Union[str, "_models.CertificateEntry"],
        body: Union[_models.X509VerificationCertificate, IO],
        **kwargs: Any
    ) -> None:
        """Verify the primary or secondary x509 certificate of an enrollment group.

        Verify the primary or secondary x509 certificate of an enrollment group by providing a
        certificate with the signed verification code.

        :param enrollment_group_id: Unique ID of the enrollment group. Required.
        :type enrollment_group_id: str
        :param entry: Entry of certificate only support primary and secondary. Known values are:
         "primary" and "secondary". Required.
        :type entry: str or ~azureiotcentral.models.CertificateEntry
        :param body: Certificate for the signed verification code. Is either a model type or a IO type.
         Required.
        :type body: ~azureiotcentral.models.X509VerificationCertificate or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "X509VerificationCertificate")

        request = build_enrollment_groups_verify_x509_request(
            enrollment_group_id=enrollment_group_id,
            entry=entry,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class FileUploadsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`file_uploads` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, **kwargs: Any) -> _models.FileUpload:
        """Get the file upload storage account configuration.

        Get the file upload storage account configuration.

        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FileUpload]

        request = build_file_uploads_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("FileUpload", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, body: _models.FileUpload, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FileUpload:
        """Create the file upload storage account configuration.

        Create the file upload storage account configuration.

        :param body: File upload storage account configuration body. Required.
        :type body: ~azureiotcentral.models.FileUpload
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(self, body: IO, *, content_type: str = "application/json", **kwargs: Any) -> _models.FileUpload:
        """Create the file upload storage account configuration.

        Create the file upload storage account configuration.

        :param body: File upload storage account configuration body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, body: Union[_models.FileUpload, IO], **kwargs: Any) -> _models.FileUpload:
        """Create the file upload storage account configuration.

        Create the file upload storage account configuration.

        :param body: File upload storage account configuration body. Is either a model type or a IO
         type. Required.
        :type body: ~azureiotcentral.models.FileUpload or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FileUpload]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "FileUpload")

        request = build_file_uploads_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("FileUpload", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, body: JSON, **kwargs: Any) -> _models.FileUpload:
        """Update the file upload storage account configuration.

        Update the file upload storage account configuration.

        :param body: File upload storage account configuration body. Required.
        :type body: JSON
        :return: FileUpload
        :rtype: ~azureiotcentral.models.FileUpload
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.FileUpload]

        _json = self._serialize.body(body, "object")

        request = build_file_uploads_update_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("FileUpload", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete the file upload storage configuration.

        Delete the file upload storage configuration.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_file_uploads_remove_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class JobsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`jobs` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Job"]:
        """Get the list of jobs in an application.

        Get the list of jobs in an application.

        :return: An iterator like instance of Job
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Job]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JobCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_jobs_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("JobCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, job_id: str, **kwargs: Any) -> _models.Job:
        """Get a job by ID.

        Get details about a running or completed job by job ID.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :return: Job
        :rtype: ~azureiotcentral.models.Job
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Job]

        request = build_jobs_get_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Job", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, job_id: str, body: _models.Job, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Job:
        """Execute a new job.

        Create and execute a new job via its job definition.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :param body: Job definition. Required.
        :type body: ~azureiotcentral.models.Job
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Job
        :rtype: ~azureiotcentral.models.Job
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, job_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Job:
        """Execute a new job.

        Create and execute a new job via its job definition.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :param body: Job definition. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Job
        :rtype: ~azureiotcentral.models.Job
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, job_id: str, body: Union[_models.Job, IO], **kwargs: Any) -> _models.Job:
        """Execute a new job.

        Create and execute a new job via its job definition.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :param body: Job definition. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Job or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Job
        :rtype: ~azureiotcentral.models.Job
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Job]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Job")

        request = build_jobs_create_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Job", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace
    def get_devices(self, job_id: str, **kwargs: Any) -> AsyncIterable["_models.JobDeviceStatus"]:
        """Get device statuses.

        Get the list of individual device statuses by job ID.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :return: An iterator like instance of JobDeviceStatus
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.JobDeviceStatus]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JobDeviceStatusCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_jobs_get_devices_request(
                    job_id=job_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("JobDeviceStatusCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def rerun(self, job_id: str, rerun_id: str, **kwargs: Any) -> _models.Job:
        """Rerun a job on failed devices.

        Execute a rerun of an existing job on all failed devices.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :param rerun_id: Unique ID of the job rerun. Required.
        :type rerun_id: str
        :return: Job
        :rtype: ~azureiotcentral.models.Job
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Job]

        request = build_jobs_rerun_request(
            job_id=job_id,
            rerun_id=rerun_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Job", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def resume(self, job_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Resume a stopped job.

        Resume execution of an existing stopped job.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_jobs_resume_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def stop(self, job_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Stop a running job.

        Stop execution of a job that is currently running.

        :param job_id: Unique ID of the job. Required.
        :type job_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_jobs_stop_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class OrganizationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`organizations` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Organization"]:
        """Get the list of organizations the user has access to in an application.

        Get the list of organizations the user has access to in an application.

        :return: An iterator like instance of Organization
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Organization]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[OrganizationCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_organizations_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("OrganizationCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, organization_id: str, **kwargs: Any) -> _models.Organization:
        """Get an organization by ID.

        Get an organization by ID.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Organization]

        request = build_organizations_get_request(
            organization_id=organization_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, organization_id: str, body: _models.Organization, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Organization:
        """Create an organization in the application.

        Create an organization in the application.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization body. Required.
        :type body: ~azureiotcentral.models.Organization
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, organization_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Organization:
        """Create an organization in the application.

        Create an organization in the application.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, organization_id: str, body: Union[_models.Organization, IO], **kwargs: Any
    ) -> _models.Organization:
        """Create an organization in the application.

        Create an organization in the application.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.Organization or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Organization]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "Organization")

        request = build_organizations_create_request(
            organization_id=organization_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, organization_id: str, body: JSON, **kwargs: Any) -> _models.Organization:
        """Update an organization in the application via patch.

        Update an organization in the application via patch.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :param body: Organization patch body. Required.
        :type body: JSON
        :return: Organization
        :rtype: ~azureiotcentral.models.Organization
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Organization]

        _json = self._serialize.body(body, "object")

        request = build_organizations_update_request(
            organization_id=organization_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Organization", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(  # pylint: disable=inconsistent-return-statements
        self, organization_id: str, **kwargs: Any
    ) -> None:
        """Delete an organization.

        Delete an organization.

        :param organization_id: Unique ID of the organization. Required.
        :type organization_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_organizations_remove_request(
            organization_id=organization_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class QueryOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`query` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def run(
        self, body: _models.QueryRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.QueryResponse:
        """Run a query and obtain the result.

        Run a query and obtain the result.

        :param body: query, more details on `IoT central query language <https://aka.ms/iotcql>`_.
         Required.
        :type body: ~azureiotcentral.models.QueryRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse
        :rtype: ~azureiotcentral.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def run(self, body: IO, *, content_type: str = "application/json", **kwargs: Any) -> _models.QueryResponse:
        """Run a query and obtain the result.

        Run a query and obtain the result.

        :param body: query, more details on `IoT central query language <https://aka.ms/iotcql>`_.
         Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryResponse
        :rtype: ~azureiotcentral.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def run(self, body: Union[_models.QueryRequest, IO], **kwargs: Any) -> _models.QueryResponse:
        """Run a query and obtain the result.

        Run a query and obtain the result.

        :param body: query, more details on `IoT central query language <https://aka.ms/iotcql>`_. Is
         either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.QueryRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: QueryResponse
        :rtype: ~azureiotcentral.models.QueryResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.QueryResponse]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "QueryRequest")

        request = build_query_run_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("QueryResponse", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class RolesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`roles` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.Role"]:
        """Get the list of roles in an application.

        Get the list of roles in an application.

        :return: An iterator like instance of Role
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Role]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[RoleCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_roles_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("RoleCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, role_id: str, **kwargs: Any) -> _models.Role:
        """Get a role by ID.

        Get a role by ID.

        :param role_id: Unique ID for the role. Required.
        :type role_id: str
        :return: Role
        :rtype: ~azureiotcentral.models.Role
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.Role]

        request = build_roles_get_request(
            role_id=role_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("Role", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


class ScheduledJobsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`scheduled_jobs` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.ScheduledJob"]:
        """Get the list of scheduled job definitions in an application.

        Get the list of scheduled job definitions in an application.

        :return: An iterator like instance of ScheduledJob
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.ScheduledJob]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[ScheduledJobCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_scheduled_jobs_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("ScheduledJobCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, scheduled_job_id: str, **kwargs: Any) -> _models.ScheduledJob:
        """Get a scheduled job by ID.

        Get details about a scheduled job by ID.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :return: ScheduledJob
        :rtype: ~azureiotcentral.models.ScheduledJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledJob]

        request = build_scheduled_jobs_get_request(
            scheduled_job_id=scheduled_job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ScheduledJob", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self,
        scheduled_job_id: str,
        body: _models.ScheduledJob,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ScheduledJob:
        """Create or update a scheduled job.

        Create or update a scheduled job by ID.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :param body: Scheduled job definition. Required.
        :type body: ~azureiotcentral.models.ScheduledJob
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ScheduledJob
        :rtype: ~azureiotcentral.models.ScheduledJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, scheduled_job_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ScheduledJob:
        """Create or update a scheduled job.

        Create or update a scheduled job by ID.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :param body: Scheduled job definition. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ScheduledJob
        :rtype: ~azureiotcentral.models.ScheduledJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, scheduled_job_id: str, body: Union[_models.ScheduledJob, IO], **kwargs: Any
    ) -> _models.ScheduledJob:
        """Create or update a scheduled job.

        Create or update a scheduled job by ID.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :param body: Scheduled job definition. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.ScheduledJob or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: ScheduledJob
        :rtype: ~azureiotcentral.models.ScheduledJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledJob]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ScheduledJob")

        request = build_scheduled_jobs_create_request(
            scheduled_job_id=scheduled_job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ScheduledJob", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, scheduled_job_id: str, body: JSON, **kwargs: Any) -> _models.ScheduledJob:
        """Update a scheduled job via patch.

        Update an existing scheduled job by ID.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :param body: Scheduled job patch. Required.
        :type body: JSON
        :return: ScheduledJob
        :rtype: ~azureiotcentral.models.ScheduledJob
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", "application/merge-patch+json")
        )  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.ScheduledJob]

        _json = self._serialize.body(body, "object")

        request = build_scheduled_jobs_update_request(
            scheduled_job_id=scheduled_job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("ScheduledJob", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(  # pylint: disable=inconsistent-return-statements
        self, scheduled_job_id: str, **kwargs: Any
    ) -> None:
        """Delete a scheduled job.

        Delete an existing scheduled job by ID.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_scheduled_jobs_remove_request(
            scheduled_job_id=scheduled_job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list_jobs(self, scheduled_job_id: str, **kwargs: Any) -> AsyncIterable["_models.Job"]:
        """Get the list of jobs for a scheduled job definition.

        Get the list of jobs for a scheduled job definition.

        :param scheduled_job_id: Unique ID of the scheduled job. Required.
        :type scheduled_job_id: str
        :return: An iterator like instance of Job
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.Job]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JobCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_scheduled_jobs_list_jobs_request(
                    scheduled_job_id=scheduled_job_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("JobCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class UsersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azureiotcentral.aio.AzureIoTCentral`'s
        :attr:`users` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncIterable["_models.User"]:
        """Get the list of users in an application.

        Get the list of users in an application.

        :return: An iterator like instance of User
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azureiotcentral.models.User]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[UserCollection]

        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_users_list_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                path_format_arguments = {
                    "baseDomain": self._serialize.url(
                        "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
                    ),
                    "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("UserCollection", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get(self, user_id: str, **kwargs: Any) -> _models.User:
        """Get a user by ID.

        Get a user by ID.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[_models.User]

        request = build_users_get_request(
            user_id=user_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("User", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create(
        self, user_id: str, body: _models.User, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.User:
        """Create a user in the application.

        Create a user in the application.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User body. Required.
        :type body: ~azureiotcentral.models.User
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, user_id: str, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.User:
        """Create a user in the application.

        Create a user in the application.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User body. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(self, user_id: str, body: Union[_models.User, IO], **kwargs: Any) -> _models.User:
        """Create a user in the application.

        Create a user in the application.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User body. Is either a model type or a IO type. Required.
        :type body: ~azureiotcentral.models.User or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.User]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "User")

        request = build_users_create_request(
            user_id=user_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("User", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def update(self, user_id: str, body: JSON, **kwargs: Any) -> _models.User:
        """Update a user in the application via patch.

        Update a user in the application via patch.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :param body: User patch body. Required.
        :type body: JSON
        :return: User
        :rtype: ~azureiotcentral.models.User
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[_models.User]

        _json = self._serialize.body(body, "object")

        request = build_users_update_request(
            user_id=user_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize("User", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def remove(self, user_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a user.

        Delete a user.

        :param user_id: Unique ID of the user. Required.
        :type user_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_users_remove_request(
            user_id=user_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "baseDomain": self._serialize.url(
                "self._config.base_domain", self._config.base_domain, "str", skip_quote=True
            ),
            "subdomain": self._serialize.url("self._config.subdomain", self._config.subdomain, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.Error, pipeline_response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})
